TODO 0.8+
Tools:
1:
    Reintroduce profile guided optimization, include in release
    Note: Library PGO can use gca files generated by profiling run (although we might
    have to set the not-exactly-same-source error to warning)
2:
    Core script for testcompare.py, like testutil.py is for test.py, i.e.
    cross-project.
3:
    Better INISection array benchmark: should search for arrays in a section
    by itself (need to find 2 tags starting with the same characters - start
    by comparing first char, then another, etc, if we get to a number in multiple
    tags starting by the same letter, find 1 and 2, if done, we can assume we
    found the array.)
4:
    Consolidate common script code to a module.
5:
    Better output than just runcmd, i.e. say what we're doing atm, like timing runtime.
    Only print runcmd with a verbose option.
6:
    Testutil.py option for human-readable
    stdout summary output.
8:
    .deb packaging script
9:
    Projects for various IDEs and make alternatives
10:
    Zip packages (for windows users)

Error checking/Debugging:
1:
     warning when whitespace is ignored in a header
     warning when [ or ] is detected in a val
     warning when there's only ] in line
     warning when there are multiple sections/tags with same name
     warning when there is [ and ] in wrong order
     warning when there is [ and/or ] with name=value separator in the same line
     warning when there are characters after ] in a line
     warning when there is [ after [
     warning when two-more tags/sections with same name and ignore all but the
             first one
2:
     For warnings: in debug mode, keep global variables to say which file,
     section, tag we're in right now, maybe which line in the file we're at?
     (when loading, at least) - if no file, (only LoadBuffer), then unknown file.
     Have a piece of code in WARNING and such that will automatically append this
     info to the warning

Interface:
1:
    Writing functionality - AddTag, AddSection, DeleteTag, DeleteSection, SetTag
2:
    A plain C wrapper, Vala wrapper, maybe a Python wrapper as well

Speed:
1:
    ReadStrings could be sped up significantly by custom strtol/strncmp/sprintf code
2:
    ReadInt/Float/Ints/Floats could be sped up significantly by custom strtol/strtof code
    Even ReadBool/s might profit slightly from a custom strcmp, though it might not be worth
    the effort.
3:
    ReadStrings code as macro in ReadInts/Floats/Bools might be useful as
    there would be no need to create a buffer of pointers to strings, they could be
    used directly
4:
    Sorting idea: When initializing static INISection data, also create
    arrays or c* for every char (i.e. 255 of them). These will be used in
    bucket sorting like so:
    When section loading, every tag goes to bucket with its starting char, and
    is sorted using the standard insert method there.
    When we're finished, concatenate the buckets to the Tags array.
    Implement this and benchmark.
    Especially benchmark this on rulesmd2.ini and on arrays (where almost all
    elems will go to the same bucket so overhead will be greatest)
5:
    Instead of 4; implement MSD radix sort.
    Both 4; and 5; have to be benchmarked on huge array input which should be
    slow for the current sort.

Refactoring:
1:
    Move static methods of INISection to a separate header
2:
    Refactor Read methods (for instance, make both ReadInt and ReadInts could
    use a private method GetInt(ui index). Where too slow, use macros. Also,
    majority of ReadXXXs share iterating code. So maybe just a private method
    that'll give them the next element with a valid name.

Docs:
1:
    What MiniINI loads and how (for instance, empty section headers are ignored)
2:
    An article about how tags are stored (i.e. name0vala0valb00)

Web:
1:
    Wiki
2:
    Mailing list

Docs:
