Reading arrays of data


There are two ways of reading arrays of data in MiniINI. The first way is to
read arrays from tags with multiple values. The other is to read from series of
numbered tags.

Reading from tags with multiple values is both faster (ini parsing wise), and
such ini files take less space. Arrays might be more practical in some cases,
though. We explain both ways here.

== ReadMultiXXX ==

MiniINI automatically parses commas as value separators, which means a value can
not contain commas. You can read values from multi value tags to arrays using
INISection methods called **ReadMultiString**, **ReadMultiInt**,
**ReadMultiFloat** and **ReadMultiBool**. These methods have both plain C data
and STL versions. Just like ReadXXX methods, they all work in a similar fashion.

Non-STL versions take name of the tag, buffer to read to and capacity of that
buffer, i.e. how many values of given type the buffer can hold. They return
number of values read (if the tag doesn't exist, that is 0). Name of the tag
**must** be a valid zero terminated string and the buffer must have at least
specified capacity. ReadMultiXXX will read **at most** as many values as
specified capacity, even if there are more in the ini file.  ReadMultiString,
like ReadString, only writes pointers (C strings) to INISection data to the
buffer, so you have to copy the data if you want to use it after the INIFile is
deleted.

STL versions are a bit simpler: Like with STL ReadXXX, name of the tag is a C++
string, and the buffer is a C++ vector. This means there is no need for the
capacity argument as vector can change its capacity. Just like the non-STL
version, number of read values is returned.

Note that if any value is of incorrect type (e.g. "abc" can't be parsed as int
when using ReadInt), only values before it are read.

Example:

If we have an ini file containing a multi value tag like this:
```
;section header, other tags
;...
images=01.png,02.png,03.png
;...
;other ini data
```

We can load that to an array like this:

Non-STL version:
```
    //load an ini file, get section...
    //...
    unsigned cap = 16;
    const char** buf = new const char* [cap];
    unsigned imgcount = section->ReadMultiString("images", buf, cap);
    if(!imgcount)
        std::cout << "ERROR: Could not find multi value tag images=";
    for(unsigned image = 0; image < imgcount; ++image)
        std::cout << buf[image] << std::endl;
    //more code and deinitiaization - don't forget to delete buf !
```

STL version:
```
    //don't forget to include <vector>
    //load an ini file, get section...
    //...
    vector<std::string> buf;
    std::string name = "images";
    unsigned imgcount = section->ReadMultiString(name, buf);
    if(!imgcount)
        std::cout << "ERROR: Could not find multi value tag images=";
    for(unsigned image = 0; image < imgcount; ++image)
        std::cout << buf[image] << std::endl;
    //more code and deinitiaization
```

== MultiValSize ==

You can see that with the non-STL version, we have to allocate a fixed space of
memory without knowing how much we need to store all the values.
To get around that, you can use INISection method **MultiValSize**. This method
determines the number of values in a tag. It takes one parameter, name of the
tag to get number of values from, and returns number of values in the tag (which
is 0 if the tag does not exist).

Non-STL example with MultiValSize:
```
    //load an ini file, get section...
    //...
    unsigned cap = section->MultiValSize("images");
    const char** buf = new const char* [cap];
    unsigned imgcount = section->ReadMultiString("images", buf, cap);
    if(!imgcount)
        std::cout << "ERROR: Could not find multi value tag images=";
    for(unsigned image = 0; image < imgcount; ++image)
        std::cout << buf[image] << std::endl;
    //more code and deinitiaization - don't forget to delete buf !
```

== ReadXXXs ==

MiniINI can also read arrays of data from series of numbered tags, such as:
```
img1=01.png
img2=02.png
img3=03.png
...
img10=10.png
```

These numbers start at 0, not 1 like C/C++ arrays. Reading arrays this way is
pretty much the same as multi-value tags. The difference is that nstead of
ReadMultiXXX and MultiValSize you use **ReadStrings**, **ReadInts**,
**ReadFloats**, **ReadBools** and **ArraySize**, and that the  first argument of
ReadXXXs is not a single tag name, but a base name used for all the numbered
tags to read from, e.g. "img" in the above example. You can even use empty
string (""), which means that tags to read from will be plain numbers like:
```
1=01.png
2=02.png
3=03.png
```
When reading arrays this way, if any index is missing in the section (say, you
have img1 and img3, but not img2), only values before that index are read. Same
thing happens if any value is of incorrect type (e.g. "abc" cannot be parsed as
int when using ReadInt).

Example:

If ini file contains this:
```
;section header, other tags
;...
img1=01.png
img2=02.png
img3=03.png
;...
;other ini data
```

We load it to array using ReadXXXs like this:

Non-STL version:
```
    //load an ini file, get section...
    //...
    unsigned cap = 16;
    const char** buf = new const char* [cap];
    unsigned imgcount = section->ReadStrings("img", buf, cap);
    if(!imgcount)
        std::cout << "ERROR: Could not find multi value tag images=";
    for(unsigned image = 0; image < imgcount; ++image)
        std::cout << buf[image] << std::endl;
    //more code and deinitiaization - don't forget to delete buf !
```

STL version:
```
    //don't forget to include <vector>
    //load an ini file, get section...
    //...
    vector<std::string> buf;
    std::string name = "img";
    unsigned imgcount = section->ReadStrings(name, buf);
    if(!imgcount)
        std::cout << "ERROR: Could not find multi value tag images=";
    for(unsigned image = 0; image < imgcount; ++image)
        std::cout << buf[image] << std::endl;
    //more code and deinitiaization
```

ArraySize works exactly the same as MultiValSize, other than that it counts
numbered tags with the given base name.

Non-STL version using ArraySize to determine number of values to allocate space
for:
```
    //load an ini file, get section...
    //...
    unsigned cap = section->ArraySize("img");
    const char** buf = new const char* [cap];
    unsigned imgcount = section->ReadStrings("img", buf, cap);
    if(!imgcount)
        std::cout << "ERROR: Could not find multi value tag images=";
    for(unsigned image = 0; image < imgcount; ++image)
        std::cout << buf[image] << std::endl;
    //more code and deinitiaization - don't forget to delete buf !
```